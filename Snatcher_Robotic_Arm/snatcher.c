#pragma config(Sensor, S1,     armTouch,       sensorTouch)
#pragma config(Sensor, S3,     colorSensor,    sensorI2CCustom)
#pragma config(Sensor, S4,     sonarSensor,    sensorSONAR)
#pragma config(Motor,  motorA,          armMotor,      tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Motor B --> Right Motor
// Motor C --> Left Motor

int distance;
int closest = 255;
//int direction = 0;

void RaiseArm ()
{
  nMotorEncoder[motorA] = 0;
  while (SensorValue(armTouch) == 0)
  {
    motor[motorA] = 35;
  }
  motor[motorA] = 0;
  wait1Msec(100);
}

void LowerArm ()
{
  while(nMotorEncoder[motorA] > 0)
  {
    motor[motorA] = -30;
  }
  motor[motorA] = 0;
  wait1Msec(100);
}

// FUNCTION THAT MOVES THE ROBOT TO GOAL


void Move (int speed1, int speed2, int centimeters)
{

	nMotorEncoder[motorB]=0;
  nMotorEncoderTarget[motorB] = (34 * centimeters);

  while(nMotorEncoder[motorB] < (34 * centimeters))
  {
   	motor[motorB] = speed1;
	  motor[motorC] = speed2;
  }
	  motor[motorB] = 0;
	  motor[motorC] = 0;
}

void Move_Closer_Sound (int speed1, int speed2, int range)
{

	while (SensorValue [sonarSensor] > range)
  {
   	motor[motorB] = speed1;
	  motor[motorC] = speed2;
  }
	  motor[motorB] = 0;
	  motor[motorC] = 0;
}

/*FUNCTION THAT ALIGN THE SNATCHER WIHT ITS GOAL*/

int Localize(int degrees_left, int search_range, int search_speed )
{
	//distance = 0;
	int closest = 255;
	int direction = 0;


	nMotorEncoder[motorB]=0;
  nMotorEncoderTarget[motorB] = degrees_left;
  motor[motorB] = search_speed;
  motor[motorC] = -search_speed;
  while(nMotorRunState[motorB] != runStateIdle)
  {
    // do nothing
  }
	motor[motorB]= 0;
	motor[motorC]= 0;
	wait10Msec(10);


  nMotorEncoder[motorC]= 0;
  nMotorEncoderTarget [motorC]= search_range;

  while (nMotorEncoder[motorC] < search_range)
  {
  	distance = SensorValue[sonarSensor];
		motor[motorB] = -search_speed;
  	motor[motorC] = search_speed;

  	if (distance < closest)
  	{
  		closest = distance;
  		direction = nMotorEncoder[motorC];
  		nxtDisplayTextLine(4,"direction: %d", direction);
  		nxtDisplayTextLine(2,"Closest: %d", closest);
  	}

	}

	motor[motorB]= 0;
	motor[motorC]= 0;
  wait10Msec(100);

  while (nMotorEncoder[motorC]> direction)
  {
  	motor[motorB]= search_speed;
		motor[motorC]= -search_speed;
  }

  motor[motorB]= 0;
	motor[motorC]= 0;
  wait10Msec(100);
  return closest;
}


task main()
{
  RaiseArm();
  Localize(400, 800, 25);

  if (closest< 30)
  {
  	Localize (100, 200, 20);
  }
	Move_Closer_Sound(15, 15, 25);
	Localize(100, 200, 10);
	LowerArm();
  Move(25, 25, 15);
  RaiseArm();
  Move(-25, -25,-20);
  Move(25, -25, 15);
  LowerArm();

}
